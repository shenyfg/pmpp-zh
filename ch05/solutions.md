# 第5章

### 解答 1

不能，因为矩阵加法每个线程都处理不同的元素，线程之间处理的数据没有共性。

### 解答 2

2 x 2 分块，每个数据使用了两次，分成四个阶段处理。
带宽减少了50%

4 x 4 分块，每个数据使用了四次，分成两个阶段处理。
带宽减少了75%

### 解答 3

如果第1个`__syncthreads`没有加上，则无法满足写后读依赖，后续计算的时候会读到旧的数据。
如果第2个`__syncthreads`没有加上，则无法满足读后写依赖，新的写入会覆盖之前的数据，导致计算结果不一致。

### 解答 4

寄存器在同一块的不同线程之间不是共享的，公共的数据，每个线程都必须从全局内存中读取，存入寄存器中。
但是共享内存是不同线程之间共享的，就可以只读取一次，减少了从全局内存中读取的次数。

### 解答 5

带宽使用减少了32倍

### 解答 6

512000个变量的版本

### 解答 7

共享内存变量在块之间共享，所以会创建1000个

### 解答 8

#### a

没有分块，每个元素请求N次

#### b

T x T 分块，每个元素请求为 N / T

### 解答 9

计算与全局内存访问的比率为 36 FLOP / (7 * 32 / 8) B = 1.29 FLOP/B

#### a

带宽限制的峰值吞吐量为 1.29 * 100 = 129 GFLOPS < 200 GFLOPS，所以是内存受限

#### b

带宽限制的峰值吞吐量为 1.29 * 250 = 322.5 GFLOPS > 300 GFLOPS，所以是计算受限

### 解答 10

#### a

只有BLOCK_SIZE=1的时候可以正确执行，在第10行和第11行之间没有并发问题

#### b

在第10行和第11行之间加一个`__syncthreads();`

### 解答 11

#### a

变量a是局部变量，保存在线程的寄存器中，所以有1024个版本

#### b

数组x[]保存在线程的本地内存中，有1024个版本

#### c

变量y_s是共享变量，有8个版本

#### d

变量b_s[]是共享变量，有8个版本

#### e

4 * (1 + 128)  = 516 个字节

#### f

浮点运算：5次乘法 + 5次加法 = 10次
全局内存访问：4 + 1 + 1 = 6次

计算/内存比率是：10 / (6 * 4) = 0.42 FLOP/B

### 解答 12

#### a

寄存器：27 \* 2048 = 55296 < 65536，满足
共享内存：4 \* (2048 / 64) = 128KB > 96KB，不满足

#### b

寄存器：31 \* 2048 = 63488 < 65536，满足
共享内存：8 \* (2048 / 256) = 64KB < 96KB，满足

可以完全占用
